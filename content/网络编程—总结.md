## 出现



+ `MSG_WAITAL`L：数据量不够时，读操作等待不返回

+ alarm：超时控制 the SIGALRM signal will be sent to the process and the process will exit with a status code of 1. This can be used to handle cases where the connection is lost or the server is unresponsive.

+  `sigemptyset(&act.sa_mask)`; 该行代码的目的是清空信号屏蔽字。信号屏蔽字是一个位掩码，用于控制在信号处理函数执行期间是否屏蔽（阻塞）某些信号。通过调用`sigemptyset`函数并传入`&act.sa_mask`参数，将信号屏蔽字设置为空，表示在信号处理函数执行期间不屏蔽任何信号。
在这个父进程的代码中，**这个设置可能是为了确保在定时器信号SIGALRM触发时，父进程能够立即响应并执行相应的处理**，而不会被其他信号的屏蔽所阻塞。
+  `sigaction(SIGALRM,&act,NULL)`;  SIGALRM 定时器到  sigaction 处理信号  act  指定捕获信号的新动作
+  `signal(SIGHUP, SIG_IGN)`; sig_IGN 忽略, 忽略信号sighup

SIGHUP signal that is sent when the controlling terminal is closed.

## 关于sigaction的总结
 1. `sigaction(SIG_ALRM,&act,NULL)`可以理解成收到SIG_ALRM信号就去执行act
 2. `act.sa_handler`的handler就是具体的act操作
 3. 可以定义为`act.sa_handler = SIG_IGN` 或者仿照2021A 中自行定义：
 ![](%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E6%80%BB%E7%BB%93_md_files/image_20230610113219.png?v=1&type=image&token=V1:riMydSeGyVGhq43BNxD6MmA3Sg0Sr4LogVWCSgEkRIk)
 4. 也就是`act.sa_handler = sigalrm_handler`
## 提到在后台运行（要用守卫进程）
这段代码用于创建一个守护进程。下面逐行解释其含义：

1.  `if(fork() != 0) exit(0);`

这行代码通过调用`fork()`创建一个子进程。如果是父进程，通过`exit(0)`使父进程退出。此时，子进程将继续执行后续代码。

2.  `if(setsid() < 0) return -1;`

`setsid()`函数用于创建一个新的会话，并使得当前进程成为会话组的首领。如果返回值小于0，表示创建会话失败，函数返回-1。

3. 

     act.sa_handler = SIG_IGN; 
     sigemptyset(&act.sa_mask); 
     act.sa_flags = 0; 
     sigaction(SIGHUP, &act, NULL);`

这几行代码设置信号SIGHUP的处理方式。`act.sa_handler = SIG_IGN`表示将SIGHUP信号的处理函数设置为忽略该信号。`sigemptyset(&act.sa_mask)`清空信号屏蔽字。`act.sa_flags = 0`表示使用默认的信号处理标志。`sigaction(SIGHUP, &act, NULL)`将上述设置应用于SIGHUP信号。

4.  `if(fork() != 0) exit(0);`

再次通过调用`fork()`创建一个子进程。如果是父进程，通过`exit(0)`使父进程退出，此时只剩下一个孤儿进程。

5.  `chdir("/");`

将当前工作目录切换到根目录，以避免守护进程影响其他文件系统操作。

6.  `umask(0);`

将文件创建的屏蔽字设置为0，即取消文件权限的屏蔽。

7.  `maxfd = sysconf(_SC_OPEN_MAX);`

通过`sysconf()`函数获取系统支持的最大文件描述符数。

8.  `for(i = 0; i < NOFILE; i++) close(i);`

关闭不需要的文件描述符，将其释放。

9.  `fd_rd = open("/dev/null", O_RDONLY); fd_wr = open("/root/daemon.log", O_WRONLY);`

通过`open()`函数打开`/dev/null`设备和`/root/daemon.log`文件，以便进行输入和输出重定向。

10.  `dup(fd_rd); dup(fd_wr); dup(fd_wr);`

使用`dup()`函数复制文件描述符，将标准输入、标准输出和标准错误输出重定向到相应的文件描述符。

11.  `signal(SIGCHLD, SIG_IGN);`

**将SIGCHLD信号的处理方式设置为忽略，防止产生僵尸进程。**

12.  `return 0;`

函数执行完毕，返回0表示成功初始化守护进程。

综上所述，该函数的作用是创建一个守护进程，包括创建子进程、设置会话、处理信号、切换工作目录、重定向文件描述符等操作，以实现守护进程的特性。

![image-20231107204644131](http://typora129.oss-cn-beijing.aliyuncs.com/img/image-20231107204644131.png)
![[img/Pasted image 20231107204854.png]]